

# [ Java Basic Grammer_6 ]

## Static

- 객체변수는 생성후 사용하기에 객체 자체가 메모리에 할당받아 사용되기에 객체명으로 사용되는게 맞다

- 하지만, `static` 은 별도의 메모리 공간이 존재하기에 클래스명으로 사용하는 것이 관례이자 효율이 좋음.

- 사용법

  ```
  - 권장
  static 변수타입 변수명 = 값;
  
  - 권장하지 않는 방법
  import static ~ --> static 으로 이루어진 멤버변수일경우 변수에 메소드명으로 바로 실행
  ```

### 패키지(Package)

- 서로 관련된 클래스와 인터페이스들의 묶음

- 클래스가 물리적으로 .class 파일인 것처럼, 패키지는 물리적으로 폴더를 의미한다.

- 패키지는 서브패키지를 가질 수 있으며, '.'으로 구분한다.

- 모든 클래스의 이름은 패키지명을 포함하고 있다.

### import문

- 사용할 클래스가 속한 패키지를 지정하는데 사용

- import문을 사용하면 클래스를 사용할때 패키지명을 생략할 수 있다.

- java.lang 패키지는 import 없이 사용가능(내장 메소드)

- 선언위치는 패키지문과 클래스선언문 사이에 한다.

- *(아스타 기호) 해당 패키지의 클래스이름의 모든 클래스를 사용가능하게 한다.

  ```
  ex) import java.util.*;
  ```

### Date() 클래스

- 현재는 서비스가 거의 중지되어서 사용하여 판매목적의 개발시 권장되지 않음

- 대신하여 Calendar() 메소드를 이용하길 권장

### 상속 구문

- 모든 자바클래스는 하나의 부모 클래스를 가진다.

- 동일 클래스에 존재하는 멤버 대신 부모 클래스의 멤버를 사용하려면 super 변수를 사용한다.

- 클래스의 객체 생성시에는 해당 클래스의 조상 클래스도 객체 생성된다.
  - 조상의 객체들도 초기화가 되도록 모든 클래스에 생성자 안에서는 조상의 생성자를 호출하는 기능이 있어야 한다. --> super()
  - this()를 호출하는 생성자는 제외

- 조상 클래스 지정시 extends 절을 사용한다.

- 상속을 통해서 조상이 가지고 있는 대부분의 멤버들을 내려받게 된다.

  - 생성자, private 형 멤버는 제외

  - 조상으로부터 물려받은 메소드들 중에서 선택적으로 오버라이딩 할 수 있다.

  - 헤더가 동일, 접근제어자가 동일하거나 넓게 지정하는 건 가능

    ```
    final 메서드 : 오버라이딩 불가
    
    abstract 메서드 : 강제로 오버라이딩 요구
    ```

### instanceof 연산자(이상 연산자)

- 전달된 매개변수가 해당 타입인지 판단하는 기능

  ```java
  (ex)
  Object o 가 매개변수
  
  o instaceof 비교타입
  ```

### Object 클래스

- 조상클래스의 최상위 클래스로서 모든 클래스가 상속받는다.

- instanceof 의 경우 object를 통해 해당 타입의 판단유무를 할 수 있다.

- Object 변수에 저장된 값을 통해 길이나 값을 읽는데 참조는 가능하지만, 접근할수 있는 멤버사양이 다르기 때문에 Object의 메소드들을 사용해 타입형변환을 통해 값을 읽고, 길이를 읽는게 좋다.

- 형변환시 앞에 (타입)을 적더라도 '.'이 최우선연산자이기에 함수가 먼저 읽혀지기때문에 괄호를 해야한다.

### 매개변수의 다형성(polymophism) ---> !!! 중요한 개념

- 조상유형의 변수로 조상의 객체뿐만 아니라 자손의 객체도 참조 할 수 있다.
  - 자손에서 추가된 멤버는 접근 불가하므로 자손유형으로 강제형변환하여 접근해야한다

- 참조형 변수는 어떤 클래스 유형의 참조형 변수냐에 따라 접근할 수 있는 멤버의 사양이 정해진다.

- 참조하게된 객체가 어떤 클래스의 객체인지 체크하고자 할 때 사용되는 연산자는 instanceof이다.

- 참조형 매개변수는 메소드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.

- 다형성이 적용되지 않는다면 메소드의 대량호출시 프로그램의 속도저하와 관리문제가 발생 할 수 있다.

### Abstract 메소드

- 미완성메서드라고 생각할 수 있다

  ```java
  abstract 리턴값의타입 메서드명([매개변수 선언....]);
  (추상클래스내에서 추상메소드는 ; 로 끝난다)
  ---> abstract 메서드를 1개 이상 선언하고 있는 클래스는 활용제어자로 abstract 를 설정해야 한다.
  ```

- 상속받는 클래스에서 오버라이딩을 통해서 재정의한다.

  ```
  abstract class 클래스명 extends 부모클래스명{
  	메서드();
  }
  ```

### Abstract 클래스

- 객체 생성 불가, 참조형 변수 선언은 가능, 상속은 가능

  (1) 기능적으로 상속으로만 사용되는 클래스를 정의할 때

  (2) 몇 개의 클래스들을 하나의 타입으로 묶고 싶을 때