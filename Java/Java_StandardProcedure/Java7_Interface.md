# [ Java Basic Grammer_7 ]

- 오버로딩 = 한 클래스 내에 같은 이름의 메소드를 여러개 정의하는 것

- 오버라이딩 = 조상 클래스로부터 상속받은 내용을 변경하는 것

- 대부분의 상수는 static형으로 선언되어진다(사용후 제거)
  - this, super 선언 위치는 생정자 첫번째 행

- 전역변수가 아닌 멤버변수라 사용을 많이 함
  - 멤버변수 안에 클래스변수와, 인스턴스변수가 존재
  - 클래스 안에 속해 있는게 클래스변수, 그 외의 변수들을 인스턴스변수

### abstract

- abstract 클래스 안에 abstract메소드가 한개라도 존재하는 한 abstract로 정의해야한다.

- abstract메소드가 존재하지 않더라도 abstract클래스를 선언할 수는 있고, 상속으로서만 사용할 수도 있다.

### 접근제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해 사용함

- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서 사용함

### API Document

- 문서에서 기울어진 문자로 표시된 메소드는 인터페이스를 의미

### Runtime 클래스

- 생성자가 없기에 new 를 쓰지않고 Runtime.getRuntime() 를 통해 불러온다.

- singleton(싱글톤) pattern을 적용하여 만들어진 클래스다.

- singleton pattern
  - 클래스의 객체를 여러번 생성해도 내부적으로 하나의 객체를 공유하게 하는 것
  - 생성자를 감춰야하기 때문에 private 등으로 감춘다. 그 후, 일반메소드로 객체를 생성한다.

- JVM에 명령을 요청하고자 할때 Runtime 클래스를 사용한다. 즉, Runtime은 JVM 으로 본다.(exec, GC 등)

  > 팩토리 메서드 : 객체 생성을 대신 해주는 일반 메소드를 말함

### 인터페이스

- 단일 상속만 지원하는 자바의 구문을 보완하기 위해 인터페이스라는 특별한 용도의 클래스 구문을 지원

- abstract 클래스와 유사하며 단일 상속의 제한이 없다.

- 상속으로만 활용가능, 객체 생성 불가

- 일반 메소드는 존재할 수 없다.

- abstract 메소드로만 구성 가능한 클래스이다(abstract public 는 생략가능)

- 형변환 주의 : TV타입으로 자식객체를 생성했을경우에 해당 자식객체의 메소드를 사용하기 위해서는 자식객체의 타입으로 강제형변환이 필요한다.(그렇지 않으면 사용이 불가)

```
(사용법)
interface 인터페이스이름 [ extends 부모인터페이스 ] {
        상수선언
         abstract 메소드
         default 메소드
}

class 클래스명 extends 부모클래스명 implements 부모인터페이스, .......(개수 제한 없음) {    

}
```

- Child : 클래스명, I1 : 인터페이스이름

- 사용 -> I1 obj = new Child();

- 인터페이스의 상속표시는 점선으로 표시하고, 일반상속의 경우는 실선 화살표이다.

### String.format()

- 사용법은 System.out.printf()와 동일하지만, 이것은 결과를 출력이 아닌 return 하는 것이다.