# [ R_Programming ]

---

## < 빅데이터 >

- 데이터 크기가 테라바이트 혹은 페타바이트까지 이르는 매우 다양한 범위의 데이터를 말함
- 정의(가트너가 정의) : BIg-Data 3V Model
  - 데이터의 기하급수적인 성장, 데이터의 가용성, 데이터의 정보화 관점에서 정의
  - High-Volume = 대용량의 데이터 규모
  - High-Velocity = 빠른 입출력 속도
  - High-Variety = 다양성
- R과 파이썬
  - R - 프로그래밍 언어이름이면서 개발환경 툴의 이름이다.
  - R 스튜디오 - R을 편리하게 사용할 수 있도록 돕는 통합개발환경(Integrated Development Environment)이다.
    - plot : 정적 그래프
    - viewer : 동적 그래프
- R의 장점과 단점
  - 장점
  - 단점

---

## < R 설치 >

- R 공식 홈페이지 접속
- R 최신버전 다운(윈도우 환경 또는 리눅스 환경에 맞춰서)
- 설치(대부분 default 설정)

---

## < R Studio 설치 >

- R Studio 홈페이지 접속 후 다운로드
- defalut 설치

---

## < R 언어의 구문 >

1. R이란

   - 통계 계산과 그래픽을 위한 프로그래밍 언어이자 소프트웨어 환경
- 뉴질랜드 오클랜드 대학의 로버트 젠틀맨과 로스 이하카에 의해 시작되어 현재는 R 코어 팀이 개발
   - 빅데이터 분석 언어
   - 시각화 언어
   
2. R에서 지원하는 데이터 타입의 종류 

   - R의 자료형

     (1) 문자형 : 문자, 문자열

     (2) 수치형 : integer, double

     (3) 복소수형 : 실수+허수

     (4) 논리형 : 참값과 거짓값

   - R의 리터럴

     (1) 문자형 리터럴 : "가나다", '가나다', "", ''

     (2) 수치형 리터럴 : 100, 3.14, 0

     (3) 논리형 리터럴 : **TRUE(T), FALSE(F)** (대문자로만)

     - NULL (데이터 셋이 비어있음을 의미)
     - **NA** (not available, 데이터 셋의 내부에 존재하지 않는 값(**결측치**)을 의미) : 오라클 null과 비슷
     - NaN (not a number, 숫자가 아님)
     - Inf (무한대값)

   - R에서 지원하는 데이터 타입의 종류

     - 타입체크 함수들

       (1) 문자형 : is.character(x)

       (2) 수치형 : is.integer(x), is.double(x)

       (3) 복소수형 : is.double(x) -> 실수+허수

       (4) 논리형 : is.logical(x) -> 참값과 거짓값

       (5) 기타 : is.null, is.na, is.nan, is.finite, is.infinite, as.logical

     - 자동 형 변환 룰

       문자형(character)(높음) > 복소수형(complex) > 수치형(numeric) > 논리형(logical)(낮음)

     - 강제 형 변환 함수

          - as.character(x)
        - as.complex(x)
        - as.numeric(x)
        - as.double(x)
        - as.integer(x)
     
     - 자료형 확인 함수
     
         - class(x)
          - str(x)
          - mode(x)

   ### 2.  데이터 셋의 종류

   > **< 데이터셋이 중요한 이유 >**
>
   >  자료를 분석하기 위해서 다양한 형태의 개별 자료를 통합적으로 분헉하기 위해서다. 예를 들어 개인 신용분석을 위해서는 개인의 소득, 부채, 성별, 학력 등등의 숫자형, 문자형 요인(Factor)형 등의 자료를 데이터 셋에 담아야 한다.
   >
   > 특히 변수와 관측값형식의 자료를 분석하기 위해서는 데이터 프레임(data.frame)을 사용한다. 데이터프레임은 모든 변수에 대해서 관측값이 같은 길이를 갖도록 만들어 놓은 것이다. 
   
스칼라(Scala, 단일값) : 10, 100은 벡터에 포함된다.
   
**벡터** (Vector, 1차원 데이터셋), 행렬, 배열 : **모든 데이터가 동일한 타입이어야 한다.**
   
   - 하나의 데이터 값도 벡터로 취급된다.
- 벡터 생성 방법 : c(), seq(), rep(), : 연산자
   - 무조건 1부터 시작한다. 인덱스에 -를 붙이면 그 값을 빼고 출력한다.
- summary() : 어떤 벡터냐에 따라 출력내용이 다르다.
   - sample(배열,개수) : 배열 안에서 개수만큼 무작위로 꺼낸다.
- R에서 다루는 가장 기초적인 데이터셋(데이터구조)로서 1차원으로 사용된다.
     - 하나의 데이터 값도 벡터로 취급된다.
  - 동일 타입의 데이터만으로 구성된다.(문자형(character) > 수치형(numeric) > 논리형(logical))
     - 벡터 생성 방법 : c(), seq(), rep()연산자
  - 미리 정의된 내장 상수 벡터들 :LETTERS, letters, month.name, month.abb, pi
     - 인덱싱:1부터 시작하는 인덱스 값과 [인덱스]연산자 사용

   팩터(factor)
   
   - 가능한 범주값(level) 만으로 구성되는 벡터이다.
  - 팩터 생성 방법 :factor(벡터), factor(벡터, levels = 레벨벡터), factor(벡터, levels=레벨벡터, ordered = TRUE)
     - 팩터의 레벨 정보 추출 : levels(팩터변수)

   **행렬**(Matrix) 

   - 동일한 타입의 데이터를 저장한다.
   - drop 속성 : 행렬구조 유지여부를 결정한다. 디폴트 값은 TRUE로 행렬구조를 유지해주지 않는다.
   - 값을 채울 때는 열 단위를 우선으로 채운다. (byrow =TRUE면 행 단위를 우선으로 채운다.)
   - dim(m) : 행렬이 몇 차원인지 체크한다.
   - nrow, ncol : 행의 개수 또는 열의 개수를 추출한다.
   - 2차원의 벡터이다.
     - 동일타입의 데이터만 저장 가능
     - 인덱싱:[행의 인덱싱, 열의 인덱싱],[행의 인덱싱, ],[,열의 인덱싱], drop 속성-행렬구조 유지 여부(인덱스를 안주면 모든 인덱스를 포함)
     - 행렬 생성 방법 
       -  matrix(data = 벡터, now = 행의 갯수, ncol=열의 갯수)
       - matrix(data = 벡터, nrow = 행의 갯수, ncol = 열의 갯수, byrow = TRUE)
    - rbind(벡터들,,,), cbind(벡터들,,,), dim(m)=행렬이 몇 차원인지 체크
       - nrow(행렬), ncol(행렬)
  - colnames(m), rownames(m), rowSums(m), colSums(m), rowMeans(m), colMeans(m)
   
   **요인** (Factor, 정해진 범주의 데이터 의미) : 범주형이냐 아니냐에 따라 그려지는 그래프가 달라진다.
   
- 정해진 값 : Level 이라 한다.
   - summary()를 하면 해당 범주 안의 원소의 개수를 세준다.
- stringAsFactors = FALSE로 주면 열이름을 마음대로 생성하지 않는다.
   
   배열(array)
   
   - 3차원 벡터이다.
     - 동일타입의 데이터만 저장 가능
     - 인덱싱 : [행의 인덱싱, 열의 인덱싱, 층(면)의 인덱스]
   - R의 연산자
   
   데이터 프레임(, 열 단위로 여러 개의 vector가 모여 있는 것) : **열마다 타입이 다를 수 있다.** csv, oracle, excel, xml 등이 속한다.
   
   - 벡터로 구성되어있다.
   - 열 단위로 서로 다른 타입의 데이터들로 구성이 가능하다.
   - **모든 열의 데이터 개수는 동일해야 한다.**
   - 리눅스: ~ : 홈디렉토리 / 윈도우: ~: 내문서
- order()를 통해 정렬한다.
   - 2차원 구조
  - 열 단위로 서로 다른 타입의 데이터들로 구성 가능
   
     - 모든 열의 데이터 개수(행의 개수)는 동일해야 한다.
   
  - 데이터 프레임 생성 방법
   
    - data.frame(벡터들...)
       - data.frame(열이름 = 벡터...)
       - data.frame(벡터들..., stringAsFactors = FALSE)
       - as.data.frame(벡터 또는 행렬 등)
   
  - 데이터 프레임 변환 
   
    - rbind(df, 벡터)
       - cbind(df, 벡터)
       - merge(df1, df2, by='key 변수')
   
     - 데이터 프레임의 구조 확인 : str(df)
   
     - 인덱싱 : [행의 인덱싱, 열의 인덱싱], [열의인덱싱], df$컬럼이름, [[열인덱싱]]
   
    - subset(df, select=컬럼명들, subset =(조건))
   
리스트 (List) : 어떤 데이터(벡터, 행렬, 함수 등)든 담을 수 있다.
   
- 서로 다른 구조의 데이터를 하나로 묵을 수 있는 자료구조이다.
   - 데이터를 꺼낼 때는 **[[ ]]** 를 사용해 꺼내야한다.
   - 사칙연산을 할 수 없다.
   - 저장 가능한 데이터의 타입, 데이터 셋의 종류에 제한이 없다. 벡터, 행렬, 배열, 데이터 프레임 드의 서로 다른 구조의 데이터를 하나로 묶을 수 있는 자료구조이다.
     - R에서는 통계 분석 결과가 리스트 구조로 제시되는 경우가 많으며 서로 다른 구조의 다수의 데이터 객체를 개별로 따로 따로 관리하는 것 보다는, 이것들을 리스트라는 한 바구니에 가지런히 정리해서 모아놓으면 관리하기 편하다.
  - list() 함수로 리스트를 생성하고, [,[[,$ 를 통해 부분집합을 뽑아낸다.
       - [ : 리스트가 포함한 하위리스트를 뽑아낸다.
    - [[,  $: 하위 리스트가 포함한 원소를 추출하고, 계층구조 수준을 한 단계 제거한다.
     - unlist() : 리스트 해제, 리스트를 벡터로 반환한다.
   
   ### 3.  연산자

   - %/% : 행렬의 곱 몫

   - %% : 행렬의 곱 나머지

   - 논리 연산자

     &, | : 모든 원소에 적용

     &&, || : 첫 번째 원소에만 적용
   
   - <<- : 전역 할당 연산자
   
   
   ### 4. R의 데이터 입출력
   
   - 출력
     - print(x, ...) : 데이터 내용 출력, 1개 출력 가능, 자동으로 개행처리됨
    - print(출력데이터 [, 옵션들])
       - quote=FALSE
    - print.gap=10
     - cat() : 메세지 출력, 여러 개 출력 가능, 개행처리 안됨, \n 사용해야함
    - cat(..., 옵션들...)
   - 파일에서 데이터 읽어들이기
  - scan("aaa.txt") : word단위로 numeric형으로 각각 원소를 벡터로 출력한다.
     - scan("aaa.txt",what="") : 주어진 파일 내용을 character형으로 읽는다.(숫자도 문자로)
  - readLines() : 행 단위로 character형으로 읽는다.
     - table() : 테이블 형으로 읽는다.
- 파일에 출력
     - write.csv(파일명)
  - write.table(파일명)
   - 모두 저장
  - save(list=ls(), file="all.rda")
   - 읽어오기 : load("all.rda")
- 한 개 저장 : save(변수명, file="one.rda")
   
   ### 5. 제어문
   
   > 주어진 명령을 수행하는데 있어서 조건에 따라서 수행여부를 정하고자 하는 경우, 필요한 만큼 반복 수행하려는 경우 모두 제어문을 사용한다. 전자의 경우에는 조건문인 if 문을 사용하며 후자의 경우에는 반복문인 for, while, repeat문을  사용한다. 제어문을 적용하여 수행하려는 명령이 여러개이면 블록({})로 구성한다.

   - if문
  
     ```R
     if(조건)
     	수행 명령문장
     	
  if(조건)
     	수행명령문장1
  else
     	수행명령문장2
  ```
     
   - ifelse함수
   
     - ifelse(조건, 조건이 참일 때 명령문1, 조건이 거짓일 때 명령문2)
     
   - switch 함수
     
     - switch(EXPR=수치데이터,식1,식2,식3...) : default 값을 줄 수 없다.
     - switch(EXPR=문자열데이터, 비교값1=식1, 비교값2=,비교값3=식3,식3) : default값을 줄 수 있다.
   
   ### 6. 함수
   
   ```R
[함수 정의]
   func1 <- function(매개변수) {
     xx <- 10
     yy <- 20
     return(xx*yy)
   }
   ```

   - 함수가 정의하고 있는 매개변수 사양에 맞춰서 꼭 아규먼트를 전달해야 한다.

   - 리턴값이 없는 함수는 NULL이 리턴된다.
   
   - return()문이 생략된 경우에는 마지막으로 출력된 데이터값이 자동으로 리턴된다. 따라서 리턴함수를 사용하여 명확히 구현하는 것이 필요하다.
   
   - 아규먼트 타입을 제한하려는 경우에는 is.xxx() 함수를 활용한다.
   
   - 기본값을 갖는 매개변수를 선언하여 선택적으로 전달되는 아규먼트를 처리할 수 있다. ex) f3<-function(p="R") print(p) ---> f3(), f3(p="PYTHON") 으로 호출가능
   
  ex) f4 <- function(p1="ㅋㅋㅋ",p2) for(i in 1:p2) print(p1) ---> f4(p2=5) 로 호출
   
- 아규먼트 개수와 타입을 가변적으로 처리 가능하다.
   
  ex) f5 <- function(...) {print("TEST"); data <- c(...); print(length(data))}
   
- 함수 안에서 만들어진 지역변수는 함수내에서만 사용 가능하다.
   
- 수행문자 1개일 때 중괄호 생략 가능하다.
   
- invisible()함수
   
  호출할 때는 return값을 표시해주지 않는다. 호출하고 변수에 담거나 다른 연산에 사용되야지 표시된다. ex) ft.3 <- function(x) invisible(x+10)
   
- stop() 함수
   
  error를 표시해주고 더 이상 수행하지 않는다.
   
- warning() 함수
   
  warning을 표시해주고 끝까지 수행한다.
   
- **try() 함수**
   
  error가 발생해도 다음을 그대로 수행한다. java의 try-catch문과 비슷하다. 많을 경우 중괄호로 묶는다. ex) try(testError(-1))
   
- tryCatch() 함수
   
  error, waring이 났을 떄 대신 수행할 함수를 지정할 수 있다.
   
  ```R
     testAll <-function(p){
    tryCatch({
         if(p=="오류테스트"){
        testError(-1)
         }else if (p =="경고테스트"){
        testWarn(6)
         }else{
        cat("정상 수행..\n")
           print(testError(2))
        print(testWarn(3))
         }
       },warning = function(w){
         print(w)
         cat("-.-;;\n")
       }, error = function(e){
         print(e)
         cat("ㅠㅠ \n")
       },finally ={
         cat("오류, 경고 발생 여부를 따라서 반드시 수행되는 부분입니다요..\n")
       })
     }
     ```